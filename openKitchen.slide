Learning go
Oktober 2019
Tags: go golang xebia

Marc Grol
Software engineer, Xebia
mgrol@xebia.com
http://www.xebia.com/
https://github.com/MarcGrol/

#----------------------------------------------

* About me

.image images/marc2.jpg
- Running, cycling

- Telecom, Finance, Mobile, Healthcare, Transport, Startups
- Allround, cost-benefit, get things done
- Running golang in production @Duxxie

#----------------------------------------------

* Approach
- Learn by example
- See code, run code
- Associate with something you already know
- Please interrupt for questions

#----------------------------------------------

* Your experience?
- Other languages?
- Go installed on laptop?
- Written any code?
- Did tour, tutorial? Read a book?
- Used go tool-chain? go get, go build, go install?
- Build http-client and http-server?
- json/xml marshalling?
- Used channels and goroutines?
- Unit testing?
- Own open-source project? Production code?

#----------------------------------------------

* Why go was created?
- Help Google solve problems: handle web requests
- Simple: limited -> easy to read
- Scale: infrastructure, teams, code bases
- Compile, startup and run fast
- Safe and reliable
- Optimum between C++ and Python

Also works for us

#----------------------------------------------

* Setup environment

- Install go:

.link https://golang.org/doc/install#download

    $ brew install go              # on mac
    $ sudo apt-get install golang  # on linux
    $ from msi file to c:\Go       # on windows

- Verify installation
    $ which go     # typically located in /usr/local/bin/
    $ go env

- Optional post installation steps
    # Add installation dir to your PATH (in ~/.bash_profile)
    $ PATH=${PATH}:/usr/local/bin

#----------------------------------------------

* Workspace:

default location is ${HOME}/go otherwise set GOPATH env-var

- Directory ${GOPATH} contains all your personal go stuff
- Convention:
    ${GOPATH}
    ├── src/   # source code
    ├── pkg/   # libraries
    └── bin/   # executables
- The tooling knows how to build

- Post installation steps

    # Set ${GOPATH}/bin in your shell startup (~/.bash_profile)
    $ export GOPATH=~/src/go
    # add GOPATH to your PATH (~/.bash_profile)
    $ export PATH=${PATH}:${GOPATH}/bin

#----------------------------------------------
* Tooling

- unix cli <--
- vi
- IntelliJ
- Goland   <--
- Sublime
- git      <--

TIP:

- Format-on-save: Use "filewatcher"-plugin with "goimports"

#----------------------------------------------

* First program

    $ mkdir -p ${GOPATH}/src/github.com/<your-github-username>/hello
    $ cd ${GOPATH}/src/github.com/<your-github-username>/hello

- Source code: first.go
.play -edit examples/hello/first.go

    $ go fmt             # standard formatter (goimports is even better)

    $ go run first.go    # compiles and runs right away
    $ go build first.go  # creates executable "hello" in .
    $ go install         # creates executable "hello" in ${GOPATH}/bin

    $ hello
    Hi everybody!

#----------------------------------------------

* Summary of language (fits on one sheet!!!!)
- Keywords: 
    break case continue default defer else fallthrough for goto if return switch
    package import func const interface map range struct type chan go select var

- Types:
	error string rune bool byte int int8 int16 int32 int64 float32 float64
	uint uint8 uint16 uint32 uint64 uintptr complex64 complex128

- Constants:
	true false iota

- Zero value:
	nil

- Functions:
	append cap close complex copy delete len make new panic recover

#----------------------------------------------

* Packages

- Each package in dedicated directory

- Standard packages shipped with go in ${GOROOT}
    source in ${GOROOT}/src/...
    compiled in ${GOROOT}/pkg/...
    example: log, strings, io, errors, time, fmt, http, ....

- Your own or third-party packages in ${GOPATH}
    source-code in ${GOPATH}/src/...
    compiled in ${GOPATH}/pkg/...
    example: ${GOPATH}/src/github.com/gin-gonic/gin

- Package name first line of source file
     package main // package that results in executable with same name as package
     package news // package that results in library "news.a"

- Packages are more coarse-grained than Java: can contain  multiple files

#----------------------------------------------

* Imports

- Use fully qualified name
- Last part short and sweet: fmt, http, log, ..

.code -edit examples/packaging/packaging.go

#----------------------------------------------

* Variables
.play -edit examples/vars/vars.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Loops
- for
.play -edit examples/for/for.go /START OMIT/,/END OMIT/
- while-like
.play -edit examples/while/while.go /START OMIT/,/END OMIT/
- iterate
.play -edit examples/iterate/iterate.go /START OMIT/,/END OMIT/

#----------------------------------------------

* If, else
.play -edit examples/if/if.go

#----------------------------------------------

* Switch
- On any type
- No fallthrough unless explicitly stated
- Multiple cases
.play -edit examples/switch/switch.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Functions
- Core building block

- Scope: based on case
 func ConvertIt( arg int ) string {
     return convertInternal( arg )
 }
 func convertInternal( arg int ) string { // internal, unexported function
     return fmt.Sprintf( "My integer value as string: %d", arg)
 }

- Can return multiple values
 func swap(x, y string) (string, string) { 
    return y, x 
 }

- Package initialisation
  func init() {
    // your global initialisations here
  }

#----------------------------------------------

* Variadic functions
.play -edit examples/variadic/variadic.go

#----------------------------------------------

* Defer
- Cleanup of file-handles, mutexes, channels and connections
- Debugging: log "enter" and "leave" of function
- Unit-testing: "setup" and "teardown"

.play -edit examples/defer/defer.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Functions as parameters
- Function-pointers, closures, anonymous functions
- Can reference variables from outside its function body.
.play -edit examples/closure/closure.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Struct and methods
- Compare Java class with methods
- Use pointer * when modifying struct
.play -edit examples/struct/struct.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Pointers
- Pass "by value" is default
- For actions that mutate data: to pass "by reference"
- Useful for passing large objects around
- Beware of side effects

  var personP *Person = new(Person)
  personP.Name = "Boogerd"
  storePerson( personP )

  or
  
  storePerson( &Person{Name:"Boogerd"} )

- Note: Slices, maps and channels are already refs
- Note: Pass by value has no side effects
.link https://github.com/MarcGrol/goopenkitchen/blob/master/pointers/pointers.go example

#----------------------------------------------

* Object construction
.play -edit examples/construct/construct.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* Enum
.play -edit examples/enum/enum.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Containers
- array
- slice
- map

#----------------------------------------------

* Array
- Fixed length immutable
     numbers := [4]int{10, 20, 30, 40}
     
     fmt.Printf( "second value: %d", numbers[1] ) 

     // idiomatic: let compiler count
     s := [...]string{"Penn", "Teller"}

- Iterate: not idiomatic
   for idx := 0 ; idx<len(s); idx++ {
      fmt.Printf("%d\n", numbers[idx])
   }

- Idiomatic:
   for _, value := range numbers {
      fmt.Printf("value: %d\n", value)
   }

#----------------------------------------------

* Slice
- Dynamic array: can grow in size
    letters := []string{"a", "b", "c", "d"}
    subslice = letters[2:3] // c and d

    slice := []string{} // very readable
    slice := make( []string, 0, 5 ) // when you want to be more in charge of allocation
    slice = append( slice, "first entry" )
    fmt.Printf( "slice-length: %d slice-capacity: %d slice-values:%+v",  
                    len(slice),
                    cap(slice),
                    slice)

- Iterate over slice (index optional -> use _)
 for idx, value := range values {
    fmt.Printf("values[%d] = %s\n", idx, value)
 }

- Sorting: use sort package

- Generics: use "gen" code-generator (github.com/clipperhouse/gen)

#----------------------------------------------

* Map
- Store key-value pairs

    m := make(map[string]int)
    m["route"] = 66
    // or preferred
    m := map[string]int {
        "route": 66,
    }
    delete(m, "route")
    i, ok := m["route"]

- Iterate over map
 for key, value := range numbers {
    fmt.Printf("%s - %d",key, value)
 }

- Random iteration order
- Not thread safe (combine with Mutex)

#----------------------------------------------

* Error handling
- Multiple return values
- if error is nil, the call worked
  resp, err := doSomethingThatCanFail(arg1, arg2)
  if err != nil {
      log.Printf("Error doing something that can fail: %s", err)
      return err // early return to minimize indentation
  }
  // continue with success path

  // use _ (=blank) if you don't care
  resp, _ := doit(arg1, arg2)

- Function signature tells that things can go wrong
- !!!!! All your own API's should use this pattern

#----------------------------------------------

* Interfaces
- UNIX filosophy: small, sharp tool combined to solve larger tasks
- Good for testability
# decribe the "what", not the "how"

- The function below accepts anything that implements the "Writer"-interface: This can be a file, buffer, stdout, network, http-response, zip-file etc

   package fmt;
   ...
   func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) { ... }

- Implement your own error in order to be able to return meaningful "restful" error-codes
   type HttpError struct {
        HttpResponseCode int
        ErrorMessage string
   }
   func (e HttpError)Error() string {
      return e.ErrorMessage
   }

# Refactor using interfaces when initially done

#----------------------------------------------

* Interface example
- Just implement the methods.
- Type it implements is not required!

.play -edit examples/interfaces/interfaces.go /START OMIT/,/END OMIT/

#----------------------------------------------

# Whatever mix of packages you use: Consumers just have to understand a single error-handling strategy

* Concurrency

Overemphasized
Most of your code is synchronous
Concurrent-style not forced upon you, used selectively


- built-in "channels" and "goroutines"
- Goroutines: think very, very lightweight threads
- Channels: think pipe or queue to communicate with goroutine(s)
- "select"-loop: UNIX-like: wait for events from multiple channels

#----------------------------------------------

* Concurrency example
- Do not communicate by sharing memory. Instead, share memory by communicating.

.play -edit examples/channels/channels.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Select example
- Waitfor events on multiple channels

.play -edit examples/select/select.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Unit testing
- Part of toolchain
- In same package, dedicated file
- Filename convention: _test.go
.code examples/testit/reverse_test.go /START OMIT/,/END OMIT/
    $ go test
    FAIL: TestDoit (0.00s)
    go_test.go:14: ERROR : Expecting[marc] Received[cram]

#----------------------------------------------

* More on testing
- Benchmarking
- Code coverage
- Race condition detection
- Http integration testing: see "httptest"-package
.link https://www.youtube.com/watch?v=ndmB0bj7eyw More details: google-search "testing techniques golang"

#----------------------------------------------

* Rich standard libraries
Just a few examples:
- flags
- file I/O
- sync
- logging
- os
- networking
- http, http2: client and server
- encoding (json, xml, mime)
- compression
- crypto
- templates
- sql
- integrating C-code
- ...

#----------------------------------------------

* Flags
- Read command-line argument
.play -edit examples/flags/flags.go /START OMIT/,/END OMIT/

#----------------------------------------------

* HTTP server
.code examples/webserver/webserver.go /START OMIT/,/END OMIT/
- Fileserver and reverse proxy included

#----------------------------------------------

* Synchronisation
- Alternative to channels
- Use for small syncs
.play -edit examples/sync/sync.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Serialisation

- Based on annotations
- xml, json etc in stdlib

example:

   type Person struct {
      Name      string   `json:"name"      xml:"PersonName"`
      Interests []string `json:"interests" xml:"PersonInterests"`
      Children  []Child  `json:"children"  xml:"Person_Children"`
   }

   type Child struct {
      Name string `json:"name"          xml:"ChildName"`
      Age  int    `json:"age,omitempty" xml:"Child_Age,omitempty"`
   }


* Serialisation example
.play -edit examples/encoding/encoding.go  /^func main/,/^}/

#----------------------------------------------

* Templating
- web-server: generate html response using template
- code-generator: generate source-code from dsl
- Minimize logic in your template (move common concerns to template.FuncMap)

.play -edit examples/template/template.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* "Kind of" generics
- go get github.com/clipperhouse/gen
.code examples/generate/generate.go
  $ go generate ./...
  generates cyclist_slice.go with "SortBy"- and "Where"-methods on CyclistSlice
- Just commit and distribute with your package
.link https://github.com/MarcGrol/goopenkitchen/blob/master/generate/cyclist_slice.go cyclist_slice.go

#----------------------------------------------

* Complete tool-chain
  $ go list ./...                  # list sub-packages
  $ go list -f {{.Deps}}           # list external deps
  
  # no flame-wars, easy to diff, allow mechanical manipulation
  $ go fmt ./...                   # format recursively or
  $ goimports -w .                # even better: adds/removes imports
  
  # fetch external packages
  $ go get golang.org/x/tools/cmd/goimports # Be effective within seconds

  # testing: tooling supports coverage, benchmark, race-condition-detection
  $ go test ./...                  # test recursively 

  # compile
  $ go build or go run             # add hoc
  $ go install                     # to ${GOPATH}/bin

  $ godoc -http=:8000              # documentation of sources in ${GOROOT} and ${GOPATH}
  $ go vet                         # lint like static analysis

- All CLI -> Easy to automate

#----------------------------------------------

* Simple build system
- Based on filesystem and conventions
- No Makefiles, autotools, build.xml, pom.xml etc
- The tool knows how to build
- Easy to integrate 3rd packages: only integrate source-code

#----------------------------------------------

* The goods
- Simple -> Easy to learn
- Source-code is easy to read and understand
- Easy deployment: self contained binary (no separate runtime)
- Supports cross compilation
- Well suited to host in the cloud: Very fast startup -> fast automatic scale-up while handling traffic spikes

#----------------------------------------------

* The not so good
# - Reproducable builds: versioning of 3rd party dependencies -> Vendoring
- No immutability by default
- Missing generics? -> Use code generation
- Go 2.0 will have generics

#----------------------------------------------

* So why go?
- Simple, readable language
- Rich standard libraries
- Complete tool-chain
- Good at concurrency
- Fast
- Easy to build and deploy
- Used by many startups
- Boring language -> is good

- Language to get things done

.link https://golang.org/

#----------------------------------------------

* Go do it
- Start experimenting
.image images/gophereartrumpet.jpg
.caption Go is cool:  Tell it around
- Let's build something

#----------------------------------------------
