Learning go
December 2019
Tags: go golang xebia

Marc Grol
Software engineer, Xebia
mgrol@xebia.com
.link  http://www.xebia.com/
.link  https://github.com/MarcGrol/

#----------------------------------------------

* About me
.image examples/images/ideal.jpg
- Running, hockey

- Telecom, Finance, Mobile, Healthcare, Transport, Startups
- Allround, cost-benefit, get things done
- Running golang in production @Duxxie

#----------------------------------------------

* Who is who?

#----------------------------------------------

* Expectations and goals

#----------------------------------------------

* Rules

#----------------------------------------------

* Agenda

Day 1:
- Startup
- Basis

Day 2:
- Advanced

Day 3:
- Exercise in groups
- Evaluation

#----------------------------------------------

* Approach
- Learn by example
- See code, run code
- Associate with something you already know
- Please interrupt for questions

#----------------------------------------------
* Language
#----------------------------------------------

* Your experience?
- Other languages?
- Go installed on laptop?
- Written any code?
- Did tour, tutorial? Read a book?
- Used go tool-chain? go get, go build, go install?
- Build http-client and http-server?
- json/xml marshalling?
- Used channels and goroutines?
- Unit testing?
- Own open-source project? Production code?

#----------------------------------------------

* Why go was created?
- Help Google solve problems: handle web requests
- Simple: limited -> easy to read
- Scale: infrastructure, teams, code bases
- Compile, startup and run fast
- Safe and reliable
- Optimum between C++ and Python

Also works for us

#----------------------------------------------

* Similarities with Java

- General purpose
- Curly-braced
- Typestrong
- Compiled
- Garbage collected
- Object oriented
- Performant

#----------------------------------------------

* Differences with Java

Missing in go:

- Generics (but has slice and map)
- Constructors (but uses "constructor" functions)
- Inheritance (but has "embedding")
- Exceptions
- Annotations

Missing in java:

- Rich standard library and toolchain
- Built-in concurrency

#----------------------------------------------

* Summary of language (fits on one sheet!!!!)
- Keywords:
    break case continue default defer else (fallthrough) for (goto) if return switch
    package import func const interface map range struct type chan go select var

- Types:
	error string rune bool byte int int8 int16 int32 int64 float32 float64
	uint uint8 uint16 uint32 uint64 (uintptr) (complex64) (complex128)

- Constants:
	true false iota

- Zero value:
	nil

- Functions:
	append cap close complex copy delete len make new (panic) (recover)

#----------------------------------------------

* Useful sources of information

https://golang.org/doc/effective_go.html

https://golangweekly.com/ (newsletter to keep up)

https://github.com/avelino/awesome-go

https://dave.cheney.net/

#----------------------------------------------

* Setup environment

#----------------------------------------------

* Installation

- Install git:

.link https://git-scm.com/download

    $ brew install git               # on mac
    $ from download                  # on windows

- Install go:

.link https://golang.org/doc/install#download

    $ brew install go              # on mac
    $ sudo apt-get install golang  # on linux
    $ from msi file to c:\Go       # on windows

- Verify installation
    $ which go     # typically located in /usr/local/bin/
    $ go env

#----------------------------------------------

* More setup (macos, unix)

- Make sure the directory of the "go"-executable is in the PATH env-var

    $ echo $PATH

    $ PATH=${PATH}:/usr/local/bin         # in ~/.bash_profile

- Set GOPATH

    $ echo $GOPATH

    $ export GOPATH=~/go                  # in ~/.bash_profile

- Make the directory of your self-made executbles is in the PATH env-var

    $ export PATH=${PATH}:${GOPATH}/bin   # in ~/.bash_profile

#----------------------------------------------

* Workspace:
- Contains all go stuff

    ${HOME}/go or c:\Go           # default

    # otherwise set the "GOPATH" environmental variable: export GOPATH=${HOME}/src/go

- Convention:
    ${GOPATH}
    ├── src/   # source code
    ├── pkg/   # libraries
    └── bin/   # executables

- The toolchain uses these conventions

#----------------------------------------------

* Training material

#----------------------------------------------

* Get the training material


    $ go get github.com/MarcGrol/goopenkitchen

Everything will end up in:

    ${GOPATH}/src/github.com/MarcGrol/goopenkitchen
    ├── openKitchen.slide
    ├── examples/
    └── exercises/

Switch to this dir:

    $ cd ${GOPATH}/src/github.com/MarcGrol/goopenkitchen

#----------------------------------------------

* Exercise: first program

#----------------------------------------------

* Dev tools

- IntelliJ IDEA or Goland
- unix terminal or windows command
- git

TIP:

- Format-on-save: Use "filewatcher"-plugin with "goimports"

#----------------------------------------------

* First program <first>

    $ cd ${GOPATH}/src/github.com/MarcGrol/goopenkitchen
    $ mkdir -p hello
    $ cd hello

- Source code: first.go

.play -edit examples/first/first.go

    $ go fmt             # standard formatter (goimports is even better)

    $ go run first.go    # compiles and runs right away
    $ go build first.go  # creates executable "hello" in .
    $ go install         # creates executable "hello" in ${GOPATH}/bin

    $ hello
    Hi everybody!


#----------------------------------------------

* Basics

#----------------------------------------------

* Creating packages
- Group related stuff
- Each package in dedicated directory
- More coarse-grained than Java: can contain  multiple files

- Package name first line of source file
     package main // package that results in executable with same name as package

or
     package news // package that results in library that is accessible via 'news'

NB:

- Minimize exported surface
- Make it short and sweet: fmt, http, log, ..

#----------------------------------------------

* Using other packages <packageusage>

- Import
- Use package-name as prefix

.play -edit examples/packageusage/main.go

#----------------------------------------------

* Comments

    /* a comment */  and // another one

Document your packages:
- Package level comment
- Every exported (capitalized) name in a program should have a comment

Verify documentation: should be a good summary

    go doc -all

Enforce rules:

    golint

- helps you minimize your public exports


#----------------------------------------------
* Commenting example <patientstore>

.play -edit examples/patientstore/patientstore.go


#----------------------------------------------

* Variables (vars)

- Name and type swapped (from Java perspective)
- Have reasonable defaults (not nil)

.play -edit examples/vars/vars.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Loops <for,while,iterate>
- for
.play -edit examples/for/for.go /START OMIT/,/END OMIT/
- while-like
.play -edit examples/while/while.go /START OMIT/,/END OMIT/
- iterate
.play -edit examples/iterate/iterate.go /START OMIT/,/END OMIT/

#----------------------------------------------

* If, else <if>
.play -edit examples/if/if.go

#----------------------------------------------

* Switch <switching>
- On any type
- No fallthrough unless explicitly stated
- Multiple cases as comma-separated list
.code -edit examples/switching/switch.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Exercise: controll structures

Create a program that calculates:

- Sum of all values from 1 to 100
- Sum incremental values untill their sum exceeds 1000
- Put calculation logic in separate library

#----------------------------------------------

* Functions
- Core building block
- Scope: based on case
- Java: static methods

 func ConvertIt( arg int ) string { // public
     return convertInternal( arg )
 }

 func convertInternal( arg int ) string { // internal, private function
     return fmt.Sprintf( "My integer value as string: %d", arg)
 }

- Can return multiple values
 func swap(x, y string) (string, string) { 
    return y, x 
 }

(More on functions later)

#----------------------------------------------

* Defer <defer>
- Cleanup of file-handles, mutexes, channels and connections
- Debugging: log "enter" and "leave" of function
- Unit-testing: "setup" and "teardown"

.play -edit examples/defer/defer.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Error handling
- Multiple return values
- if error is nil, the call worked
  resp, err := doSomethingThatCanFail(arg1, arg2)
  if err != nil {
      return fmt.Errorf("Error doing something that can fail: %s", err) // early return to minimize indentation
  }
  // continue with success path

  // use _ (=blank) if you don't care
  resp, _ := doit(arg1, arg2)

- Function signature tells that things can go wrong
- Keep indentation low

!!! All your own API's should use this pattern !!!

#----------------------------------------------

* Exercise: error-handling

File access using the ioutil-package:

- Read a file
- Capitalize the content of the file
- Write this capitalized content to a new other name
- Use Proper error-handling

#----------------------------------------------

* Data

#----------------------------------------------

* Struct <struct>
- No constructor
- Case of variable determines accessibility (private, public)

.play -edit examples/struct/struct.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Struct methods <methods>

.play -edit examples/methods/methods.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Pointers
- Default value: nil
- For passing large objects around (prevent copy overhead)

  var ho *HugeObject = &HugeObject{} // ho := &HugeObject{}
  ho := new(HugeObject)
  insuranceService.CalculateRisk( hu )

- For methods that mutate data

  func (p Patient)MarkDeceased() { // won't adjust patient
    p.Deceased = true
  }
  func (p *Patient)MarkDeceased() { // will work
    p.Deceased = true
  }

- Indicate Optional (poor mans)

  type Person struct {
    Name string
    Child *Person // optional
  }

#----------------------------------------------

* Enumerations <enum>

.play -edit examples/enum/enum.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Exercise: data

- Model your business domain using structs, enums and pointers
- Might need slices (see next section)

#----------------------------------------------

* Containers

- array and slice
- map

#----------------------------------------------

* Slices
- Can contain everything: primitives, structs, slices, maps etc
- Like Java ArrayList
- Sortable
- Supported operations:

    append, replace, get-on-idx, get-on-range, iterate

Fixed length immutable

    numbers := [4]int{10, 20, 30, 40}
    s := [...]string{"Voetbal", "Hockey"} // idiomatic: let compiler count

Dynamic size

    var slice0 []string = []string{}   // empty
    slice1 := []string{}               // empty
    slice2 := []string{"a", "b", "c"}  // initialize with data
    slice3 := make( []string, 0, 5 )   // optimization: empty with reserved capacity

- Not thread safe (combine with Mutex)

#----------------------------------------------

* Slices in action <slice>

.play -edit examples/slice/slice.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Map
- Store key-value pairs (like Java HashMap)
- Typically key is primitive, value can be everything: primitives, structs, slices, maps etc
- Supported operations:

    get-on-key, put-on-key, replace-on-key, delete-on-key, iterate

initialization:

    var m1 map[string]int = make(map[string]int)
    m2 := make(map[string]int)
    m3 := map[string]int{}
    m4 := map[string]int{
         "route": 66,
    }

- Random iteration order
- Not thread safe (combine with Mutex)

#----------------------------------------------
* Maps in action <maps>

.play -edit examples/maps/maps.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Exercise: slices and maps

Use maps and slices to group the following people on hobby:

    Julia: voetbal tekenen
    Sophie: hockey
    Mila: tekenen
    Emma: volleybal, turnen
    Tess: hardlopen
    Zoë: kunst, voetbal
    Noor: voetbal
    Elin: hockey
    Sara: voetbal, turnen
    Yara: tekenen

#----------------------------------------------
* Interfaces
#----------------------------------------------

* Interfaces
- Duck-typing: no explicit "implements"
- Good to improve testability

example from stdlib

   package fmt;
   // Accepts anything that implements the "Writer"-interface:
   // Examples of Writers: file, buffer, stdout, network, http-response, zip-file etc
   func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) { ... }

other example

   // The business logic layer can return this EnrichedError as regular 'error' .
   // The http layer convert this error into an appropriate http-response (200, 400, 403, 500 etc)
   type EnrichedError struct {
        Kind ErrorKind // invalid-input, not-authorized, internal-error etc
        Message string
   }
   func (e HttpError)Error() string { // implement Error-interface
      return e.Message
   }

# Refactor using interfaces when initially done

#----------------------------------------------

* Interface <interfaces>
- Naming convention: ends with "er"
- Keep them small. Why?
- Composeable


.code -edit examples/interfaces/storeApi.go /START OMIT/,/END OMIT/

#----------------------------------------------
* Example usage of interface <interfaces>
- For dependency injection
- The business logic of PatientService is testable without a "real"-datastore

.code -edit examples/interfaces/main.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* Exercise: interfaces

Implement a simple in-memory database that implements the following interface:

    type Datastorer interface {
    	Put(key string, value interface{}) error
    	Get(key string) (interface{}, bool, error)
    	Remove(key string) error
    }

#----------------------------------------------
* Testing
#----------------------------------------------

* Testing

Essential for software with a long predicted lifetime

Why:

- Need “Safety-net" so you dare to keep improving and extending your software

How:

- Do from beginning
- Tests should be easy and fast to run
- Test against the API: not against the internals
- Prefer HTTP (as the ultimate API) to trigger your business logic, so you have freedom to change the internals and still keep your safety net intact


#----------------------------------------------

* Unit testing <testit>
- Part of toolchain
- In same package, dedicated file
- Filename convention: _test.go

.code examples/testit/reverse_test.go /START OMIT/,/END OMIT/

    $ go test
    --- FAIL: TestReverseAscii (0.00s)
        reverse_test.go:13: ERROR : Expecting[marc] Received[cram]
    FAIL
    exit status 1

#----------------------------------------------
* Table driven test
- Used a lot in the stdlib
- Very readable
- Easy to be complete

    func TestSplit(t *testing.T) {
        tests := []struct { // anonymous struct
            input,sep string, want []string
        }{
            {input: "a/b/c", sep: "/", want: []string{"a", "b", "c"}},
            {input: "a/b/c", sep: ",", want: []string{"a/b/c"}},
            {input: "abc", sep: "/", want: []string{"abc"}},
        }

        for _, tc := range tests {
            got := Split(tc.input, tc.sep)
            if !reflect.DeepEqual(tc.want, got) {
                t.Fatalf("expected: %v, got: %v", tc.want, got)
            }
        }
    }

#----------------------------------------------
* Design for testability: Use dependency injection

    package uniqueid

    // Generator provides an interface for creating uuid's.
    type Generator interface {
        Generate() string
    }

Service must internally create uuid's:

    package patient

    type Service struct {
        uuidGenerator uniqueid.Generator
    }

    func New(uuidGenerator uniqueid.Generator) *Service {
        return &Service{
            uuidGenerator: uuidGenerator,
        }
    }

- This pattern also suited to replace direct calls to time.Now() or manage access to databases etc

#----------------------------------------------
* Mocks and stubs

- Create by hand
- Generate from interface using mockgen

    package uniqueid

    //go:generate mockgen -source=api.go -destination=gen_GeneratorMock.go -package=uniqueid \
       github.com/MarcGrol/forwardhttp/uniqueid Generator

    type Generator interface {
    	Generate() string
    }

Trigger generation:

    go generate ./...

#----------------------------------------------

* Benchmarking <benchmark>
- Premature optimization is ...
- Never optimize before measuring first

.code examples/benchmark/mycalclib_test.go /START OMIT/,/END OMIT/

- On profiling: https://www.youtube.com/watch?v=O-bJ4s8OdcA

#----------------------------------------------

* More on testing
- Standard library offers utils for testing http-clients and http-servers
- Code coverage: IntellijIDEA
- Race condition detection
- Continuous integration

#----------------------------------------------

* Exercise: tests

#----------------------------------------------
* Concurrency
#----------------------------------------------

# Whatever mix of packages you use: Consumers just have to understand a single error-handling strategy

* Concurrency

Overemphasized
Most of your code is synchronous
Concurrent-style not forced upon you, used selectively

- built-in "channels" and "goroutines"
- Goroutines: think very, very lightweight threads
- Channels: think pipe or queue to communicate with goroutine(s)
- "select"-loop: UNIX-like: wait for events from multiple channels

#----------------------------------------------

* Concurrency example <channels>
- Do not communicate by sharing memory. Instead, share memory by communicating.

.play -edit examples/channels/channels.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Select example <select>
- Waitfor events on multiple channels

.play -edit examples/select/select.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Exercise: concurrency

#----------------------------------------------

* The standard library

#----------------------------------------------

* Rich standard libraries
Just a few examples:
- flags
- file I/O
- sync
- logging
- os
- sort
- networking
- http, http2: client and server
- encoding (json, xml, mime)
- compression
- crypto
- templates
- sql
- integrating C-code
- ...


#----------------------------------------------

* Serialisation

- Based on annotations
- xml, json etc in stdlib

example:

   type Person struct {
      Name      string   `json:"name"      xml:"PersonName"`
      Interests []string `json:"interests" xml:"PersonInterests"`
      Children  []Child  `json:"children"  xml:"Person_Children"`
   }

   type Child struct {
      Name string `json:"name"          xml:"name"`
      Age  int    `json:"age,omitempty" xml:"age,omitempty"`
   }


* Serialisation example <encoding>
.play -edit examples/encoding/encoding.go  /^func main/,/^}/

#----------------------------------------------

* Exercise: json and xml

#----------------------------------------------

* Flags <flags>

- Read command-line arguments
.play -edit examples/flags/flags.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Exercise: command-line flags

#----------------------------------------------
* HTTP
#----------------------------------------------

* HTTP client

Request and response:

- Request.Method: POST, PUT, DELETE and GET
- Request.Url: REST-ful?
- *.Headers: Content-Type, Accept, Authorization (Basic or Bearer)
- *.Payload: Json, XML
- Timeout
- Response.StatusCode: 200, 201, 202, 301, 307, 400, 401, 403, 404, 500, 501, 503

Based on Swagger/OpenApi-spec?

Standard library provides API

#----------------------------------------------

* Example <myhttpclient>

.code examples/myhttpclient/main.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Exercise: http client

#----------------------------------------------

* HTTP server

- Methods: POST, PUT, DELETE, GET AND HEAD
- Url: REST-ful?
- Payload: Json, XML
- Middleware for non-functionals (CORS, Auth, Monitoring)
- Response status-code and error-message

Based on Swagger/OpenApi-spec?

Standard library provides API:

- HTTP/2 capable
- Each request runs in its own goroutine

#----------------------------------------------

* Example <webserver>

.code examples/webserver/webserver.go /START OMIT/,/END OMIT/
- Fileserver and reverse proxy included

#----------------------------------------------

* Middleware <middleware>

- Like Java "servlet filters"

Example with "Alice"

.code examples/middleware/main.go /START OMIT/,/END OMIT/

- Later more on middleware functions

#----------------------------------------------

* Exercise: http server

#----------------------------------------------

* Tooling

#----------------------------------------------
* Dependency management

The old way:

Use GOPATH and go get:
- Fetch latest and greatest versions of your dependencies
- Rely on well behaving citizens: backwards compatility
- Repair work unpredictable: Upgrade your own code or offer pr on dependency
- Okay when you test, build and deploy every day

The new way:

Use go modules:
- Stores versions of dependencies within project to have reproducable builds
- Repair work more predictable: you decide when and what to upgrade
- If build broken, downgrade to lower version of dependency or upgrade your own code
- Depends on semantic versioning:

    major.minor.release
    breaking.feature.fix

#----------------------------------------------
* Go modules

What is a module?

- Collection of Go packages stored in a file tree with a go.mod file at its root

Create a module

    go mod init github.com/my/project # creates a new go.mod file
    go build ./... && go test ./...   # adds regular and test dependencies
    go mod tidy                       # add transitive dependencies
    go list -m all

Upgrade a module

    go list -m -versions github.com/my/dependency1
    go install github.com/my/dependency1
    go install github.com/other/dependency2@v1.0.3

Major version upgrade appears in the import path

    import (
        "rsc.io/quote"
        quoteV3 "rsc.io/quote/v3"
    )

#Backwards compatibilty:
#- If an old package and a new package have the same import path,
#  the new package must be backwards compatible with the old package.
#- One does not lighty introduce a new major version, because it requires you to maintain multiple trees

#----------------------------------------------

* Exercise: add go modules to an existing project

#----------------------------------------------

* Debugging

- Use intelliJ IDEA or Goland

#----------------------------------------------

* Exercise: fix using debugger


#----------------------------------------------
* Static analysis <staticanalysis>

.code examples/staticanalysis/staticanalysis.go

- go vet, golint, gocyclo, varcheck, errcheck, test-coverage, ...
=> goreporter

#----------------------------------------------

* Exercise: detect problems with static analysis tools

#----------------------------------------------

* Dependency analysis

- Golang does not allow cyclic dependencies :)
- Standard tooling

    go list -f '{{ .Name }}: {{ .Doc }}' # current package
    go list -f '{{ join .Imports  "\n" }}' # Nice input for a script

- Try to minimize your dependencies
- Sometimes a little duplication is better than introducing a huge dependency
- Duck-typing allows add-hoc interface creation

#----------------------------------------------

* Exercise: dependency analysis

#----------------------------------------------
* More on functions
#----------------------------------------------

* Package initialisation
- Executed only once at startup
- Can be multiple
- For advanced initialisations

  func init() {
    // your global initialisations here
  }

#----------------------------------------------

* Variadic functions <variadic>
.play -edit examples/variadic/variadic.go

#----------------------------------------------

* Closures <binarysearch>

- Alternative to single method interfaces

example: binary search

.play -edit examples/binarysearch/main.go

#----------------------------------------------
* More examples usages of closures

- HTTP middleware

example: measure duration of http-call

    func timed(f http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            f(w, r)
            end := time.Now()
            fmt.Println("The request took", end.Sub(start))
        }
    }


#----------------------------------------------

* More examples usages of closures

- Pass data into handlers without global data

    func main() {
      db := NewDatabase("localhost:5432")

      http.HandleFunc("/hello", hello(db))
      http.ListenAndServe(":3000", nil)
    }

    func hello(db Database) func(http.ResponseWriter, *http.Request) {
      return func(w http.ResponseWriter, r *http.Request) {
        // has access to db without using globals vars
        ...
      }
    }

#----------------------------------------------


* More examples usages of closures <fireforget>

combine with go routines to execute work in background

.play -edit examples/fireforget/main.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Overridable functions <emailapi>
- Interfaces more suitable for overriding however you might encounter this

.code -edit examples/emailapi/api.go

- Can be useful in combination with build-tags

#----------------------------------------------

* Extras

#----------------------------------------------

* Contract based interfaces
- Swagger/OpenApi spec
- GRPC (Protocol buffers)
- (WSDL/XSD)

#----------------------------------------------

* Templating <template>

- web-server: generate html response using template
- code-generator: generate source-code from dsl
- Minimize logic in your template (move common concerns to template.FuncMap)

.play -edit examples/template/template.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* Synchronisation <sync>
- Alternative to channels
- Use for small syncs or lazy initialisation
.play -edit examples/sync/sync.go /START OMIT/,/END OMIT/

#----------------------------------------------

* "Kind of" generics <generate>
- go get github.com/clipperhouse/gen
.code examples/generate/generate.go
  $ go generate ./...
  generates cyclist_slice.go with "SortBy"- and "Where"-methods on CyclistSlice
- Just commit and distribute with your package

.link https://github.com/MarcGrol/goopenkitchen/blob/master/examples/generate/cyclist_slice.go cyclist_slice.go

#----------------------------------------------

* Parsing go

- Extract documentation from code
- Create boiler-plate code
- stdlib provides api:
    import (
        "go/ast"
        "go/parser"
        "go/token"
    )

Example:

- github.com/MarcGrol/golangAnnotations
- Used in large scale project

#----------------------------------------------


#----------------------------------------------

* Understandability is king

.image examples/images/sweet.png

#----------------------------------------------

* Just start

.image examples/images/minimum.png


#----------------------------------------------

* Conclusions

#----------------------------------------------

* Expectations and goals

#----------------------------------------------

* Improvements

#----------------------------------------------

* What's next?

#----------------------------------------------

* Done!

#----------------------------------------------

* Complete tool-chain
  $ go list ./...                  # list sub-packages
  $ go list -f {{.Deps}}           # list external deps
  
  # no flame-wars, easy to diff, allow mechanical manipulation
  $ go fmt ./...                   # format recursively or
  $ goimports -w .                # even better: adds/removes imports
  
  # fetch external packages
  $ go get golang.org/x/tools/cmd/goimports # Be effective within seconds

  # testing: tooling supports coverage, benchmark, race-condition-detection
  $ go test ./...                  # test recursively 

  # compile
  $ go build or go run             # add hoc
  $ go install                     # to ${GOPATH}/bin

  $ godoc -http=:8000              # documentation of sources in ${GOROOT} and ${GOPATH}
  $ go vet                         # lint like static analysis

- All CLI -> Easy to automate



#----------------------------------------------

* Simple build system
- Based on filesystem and conventions
- No Makefiles, autotools, build.xml, pom.xml etc
- The tool knows how to build
- Easy to integrate 3rd packages: only integrate source-code

#----------------------------------------------

* The goods
- Simple -> Easy to learn
- Source-code is easy to read and understand
- Easy deployment: self contained binary (no separate runtime)
- Supports cross compilation
- Well suited to host in the cloud: Very fast startup -> fast automatic scale-up while handling traffic spikes

#----------------------------------------------

* The not so good
- No immutability by default
- Missing generics? -> Use code generation
- Go 2.0 will have generics

#----------------------------------------------

* So why go?
- Simple, readable language
- Rich standard libraries
- Complete tool-chain
- Good at concurrency
- Fast
- Easy to build and deploy
- Used by many startups
- Boring language -> is good

- Language to get things done

.link https://golang.org/

#----------------------------------------------

* Go do it
- Start experimenting
.image examples/images/gophereartrumpet.jpg
.caption Go is cool:  Tell it around
- Let's build something


#----------------------------------------------
* Extra's
#----------------------------------------------

* Wrapping errors
TODO
