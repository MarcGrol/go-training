Learning go
December 2019
Tags: go golang xebia

Marc Grol
Software engineer, Xebia
mgrol@xebia.com
http://www.xebia.com/
https://github.com/MarcGrol/

#----------------------------------------------

* About me

.image examples/images/ideal.jpg
- Running, cycling

- Telecom, Finance, Mobile, Healthcare, Transport, Startups
- Allround, cost-benefit, get things done
- Running golang in production @Duxxie

#----------------------------------------------

* Approach
- Learn by example
- See code, run code
- Associate with something you already know
- Please interrupt for questions

#----------------------------------------------
* Language
#----------------------------------------------

* Your experience?
- Other languages?
- Go installed on laptop?
- Written any code?
- Did tour, tutorial? Read a book?
- Used go tool-chain? go get, go build, go install?
- Build http-client and http-server?
- json/xml marshalling?
- Used channels and goroutines?
- Unit testing?
- Own open-source project? Production code?

#----------------------------------------------

* Why go was created?
- Help Google solve problems: handle web requests
- Simple: limited -> easy to read
- Scale: infrastructure, teams, code bases
- Compile, startup and run fast
- Safe and reliable
- Optimum between C++ and Python

Also works for us


#----------------------------------------------

* Similarities with Java

- General purpose
- Curly-braced
- Typestrong
- Compiled
- Garbage collected
- Object oriented
- Performant

#----------------------------------------------

* Differences with Java

Missing in go:

- Generics (but has slice and map)
- Constructors
- Inheritance
- Exceptions
- Annotations

Missing in java:

- Rich standard library and toolchain
- Built-in concurrency

#----------------------------------------------

* Optimal

.image examples/images/sweet.png

#----------------------------------------------

* Don't be afraid

.image examples/images/minimum.png


#----------------------------------------------

* Setup environment

#----------------------------------------------

* Installation

- Install git:

.link https://git-scm.com/download

    $ brew install git               # on mac
    $ from download                  # on windows

- Install go:

.link https://golang.org/doc/install#download

    $ brew install go              # on mac
    $ sudo apt-get install golang  # on linux
    $ from msi file to c:\Go       # on windows

- Verify installation
    $ which go     # typically located in /usr/local/bin/
    $ go env

#----------------------------------------------

* More setup (macos, unix)

- Make sure the directory of the "go"-executable is in the PATH env-var

    $ echo $PATH

    $ PATH=${PATH}:/usr/local/bin         # in ~/.bash_profile

- Set GOPATH

    $ echo $GOPATH

    $ export GOPATH=~/go                  # in ~/.bash_profile

- Make the directory of your self-made executbles is in the PATH env-var

    $ export PATH=${PATH}:${GOPATH}/bin   # in ~/.bash_profile

#----------------------------------------------

* Workspace:
- Contains all go stuff

    ${HOME}/go or c:\Go           # default

    # otherwise set the "GOPATH" environmental variable: export GOPATH=${HOME}/src/go

- Convention:
    ${GOPATH}
    ├── src/   # source code
    ├── pkg/   # libraries
    └── bin/   # executables

- The toolchain uses these conventions

#----------------------------------------------

* Training material

#----------------------------------------------

* Get the training material


    $ go get github.com/MarcGrol/goopenkitchen

Everything will end up in:

    ${GOPATH}/src/github.com/MarcGrol/goopenkitchen
    ├── openKitchen.slide
    ├── examples/
    └── exercises/

Switch to this dir:

    $ cd ${GOPATH}/src/github.com/MarcGrol/goopenkitchen

#----------------------------------------------

* Useful sources of information

https://golang.org/doc/effective_go.html

https://golangweekly.com/ (newsletter to keep up)

https://github.com/avelino/awesome-go

#----------------------------------------------

* Exercise: first program

#----------------------------------------------

* Dev tools

- IntelliJ IDEA or Goland
- unix terminal or windows command
- git

TIP:

- Format-on-save: Use "filewatcher"-plugin with "goimports"

#----------------------------------------------

* First program

    $ cd ${GOPATH}/src/github.com/MarcGrol/goopenkitchen
    $ mkdir -p hello
    $ cd hello

- Source code: first.go

.play -edit examples/hello/first.go

    $ go fmt             # standard formatter (goimports is even better)

    $ go run first.go    # compiles and runs right away
    $ go build first.go  # creates executable "hello" in .
    $ go install         # creates executable "hello" in ${GOPATH}/bin

    $ hello
    Hi everybody!


#----------------------------------------------

* Basics

#----------------------------------------------

* Creating packages
- Group related stuff
- Each package in dedicated directory
- More coarse-grained than Java: can contain  multiple files

- Package name first line of source file
     package main // package that results in executable with same name as package

or

     package news // package that results in library that is accessible via 'news'

NB:

- Minimize exported surface
- Make it short and sweet: fmt, http, log, ..

#----------------------------------------------

* Using other packages

- Import
- Use package-name as prefix

.play -edit examples/packageusage/main.go

#----------------------------------------------

* Comments

    /* */  and //

Document your packages:
- Package level comment
- Every exported (capitalized) name in a program should have a comment

Verify documentation: should be a good summary

    go doc -all

Enforce rules:

    golint

- helps you minimize your public exports


#----------------------------------------------
* Commenting example

.play -edit examples/patientstore/patientstore.go


#----------------------------------------------

* Variables

- Name and type swapped (from Java perspective)
- Have reasonable defaults (not nil)

.play -edit examples/vars/vars.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Loops
- for
.play -edit examples/for/for.go /START OMIT/,/END OMIT/
- while-like
.play -edit examples/while/while.go /START OMIT/,/END OMIT/
- iterate
.play -edit examples/iterate/iterate.go /START OMIT/,/END OMIT/

#----------------------------------------------

* If, else
.play -edit examples/if/if.go

(switch-case will be demonstrated later)
#----------------------------------------------

* Functions
- Core building block

- Scope: based on case
 func ConvertIt( arg int ) string {
     return convertInternal( arg )
 }
 func convertInternal( arg int ) string { // internal, unexported function
     return fmt.Sprintf( "My integer value as string: %d", arg)
 }

- Can return multiple values
 func swap(x, y string) (string, string) { 
    return y, x 
 }

(More on functions will be demonstrated later)

#----------------------------------------------

* Error handling
- Multiple return values
- if error is nil, the call worked
  resp, err := doSomethingThatCanFail(arg1, arg2)
  if err != nil {
      return fmt.Errorf("Error doing something that can fail: %s", err) // early return to minimize indentation
  }
  // continue with success path

  // use _ (=blank) if you don't care
  resp, _ := doit(arg1, arg2)

- Function signature tells that things can go wrong
- !!!!! All your own API's should use this pattern

#----------------------------------------------

* Excercise: functions, loops, if

#----------------------------------------------

* Struct
- No constructor
- Case of variable determines accessibility (private, public)

.play -edit examples/struct/struct.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Struct methods

.play -edit examples/methods/methods.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Pointers
- Default value: nil
- For passing large objects around (prevent copy overhead)

  var ho *HugeObject = &HugeObject{} // ho := &HugeObject{}
  ho := new(HugeObject)
  insuranceService.CalculateRisk( hu )

- For methods that mutate data:

  func (p Patient)MarkDeceased() { // won't adjust patient
    p.Deceased = true
  }
  func (p *Patient)MarkDeceased() { // will work
    p.Deceased = true
  }

- Indicate Optional (poor mans)

  type Person struct {
    Name string
    Child *Person // optional
  }

#----------------------------------------------

* Enumerations in action

.play -edit examples/enum/enum.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Exercise: structs, enums and pointers

#----------------------------------------------

* Containers

- array and slice
- map

#----------------------------------------------

* Slices
- Can contain everything: primitives, structs, slices, maps etc
- Like Java ArrayList
- Sortable
- Supported operations:

    append, replace, get-on-idx, get-on-range, iterate

Fixed length immutable

    numbers := [4]int{10, 20, 30, 40}
    s := [...]string{"Voetbal", "Hockey"} // idiomatic: let compiler count

Dynamic size

    var slice0 []string = []string{}   // empty
    slice1 := []string{}               // empty
    slice2 := []string{"a", "b", "c"}  // initialize with data
    slice3 := make( []string, 0, 5 )   // optimization: empty with reserved capacity

- Not thread safe (combine with Mutex)

#----------------------------------------------

* Slices in action

.play -edit examples/slice/slice.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Map
- Store key-value pairs (like Java HashMap)
- Typically key is primitive, value can be everything: primitives, structs, slices, maps etc
- Supported operations:

    get-on-key, put-on-key, replace-on-key, delete-on-key, iterate

initialization:

    var m1 map[string]int = make(map[string]int)
    m2 := make(map[string]int)
    m3 := map[string]int{}
    m4 := map[string]int{
         "route": 66,
    }

- Random iteration order
- Not thread safe (combine with Mutex)

#----------------------------------------------
* Maps in action

.play -edit examples/maps/maps.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Exercise: slices and maps

#----------------------------------------------
* Interfaces
#----------------------------------------------

* Interfaces
- Duck-typing: no explicit "implements"
- Good to improve testability

example from stdlib

   package fmt;
   // Accepts anything that implements the "Writer"-interface:
   // Examples of Writers: file, buffer, stdout, network, http-response, zip-file etc
   func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) { ... }

other example

   // The business logic layer can return this EnrichedError as regular 'error' .
   // The http layer convert this error into an appropriate http-response (200, 400, 403, 500 etc)
   type EnrichedError struct {
        Kind ErrorKind // invalid-input, not-authorized, internal-error etc
        Message string
   }
   func (e HttpError)Error() string { // implement Error-interface
      return e.Message
   }

# Refactor using interfaces when initially done

#----------------------------------------------

* Interface
- Naming convention: ends with "er"
- Keep them small. Why?
- Composeable


.code -edit examples/interfaces/storeApi.go /START OMIT/,/END OMIT/

#----------------------------------------------
* Example usage of interface
- For dependency injection
- The business logic of PatientService is testable without a "real"-datastore

.play -edit examples/interfaces/main.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* Excercise: interfaces

#----------------------------------------------
* Testing
#----------------------------------------------
* Why?

TODO
#----------------------------------------------

* Unit testing
- Part of toolchain
- In same package, dedicated file
- Filename convention: _test.go
.code examples/testit/reverse_test.go /START OMIT/,/END OMIT/
    $ go test
    FAIL: TestDoit (0.00s)
    go_test.go:14: ERROR : Expecting[marc] Received[cram]

#----------------------------------------------

* More on testing
- Benchmarking
- Code coverage
- Race condition detection
- Http integration testing: see "httptest"-package
.link https://www.youtube.com/watch?v=ndmB0bj7eyw More details: google-search "testing techniques golang"

#----------------------------------------------

* Exercise: test

#----------------------------------------------
* Concurrency
#----------------------------------------------

# Whatever mix of packages you use: Consumers just have to understand a single error-handling strategy

* Concurrency

Overemphasized
Most of your code is synchronous
Concurrent-style not forced upon you, used selectively

- built-in "channels" and "goroutines"
- Goroutines: think very, very lightweight threads
- Channels: think pipe or queue to communicate with goroutine(s)
- "select"-loop: UNIX-like: wait for events from multiple channels

#----------------------------------------------

* Concurrency example
- Do not communicate by sharing memory. Instead, share memory by communicating.

.play -edit examples/channels/channels.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Select example
- Waitfor events on multiple channels

.play -edit examples/select/select.go /START OMIT/,/END OMIT/


#----------------------------------------------

* Exercise: concurrency

#----------------------------------------------

* Rich standard libraries
Just a few examples:
- flags
- file I/O
- sync
- logging
- os
- sort
- networking
- http, http2: client and server
- encoding (json, xml, mime)
- compression
- crypto
- templates
- sql
- integrating C-code
- ...


#----------------------------------------------

* Serialisation

- Based on annotations
- xml, json etc in stdlib

example:

   type Person struct {
      Name      string   `json:"name"      xml:"PersonName"`
      Interests []string `json:"interests" xml:"PersonInterests"`
      Children  []Child  `json:"children"  xml:"Person_Children"`
   }

   type Child struct {
      Name string `json:"name"          xml:"name"`
      Age  int    `json:"age,omitempty" xml:"age,omitempty"`
   }


* Serialisation example
.play -edit examples/encoding/encoding.go  /^func main/,/^}/

#----------------------------------------------

* Excercise: json, xml and protocol buffers

#----------------------------------------------

* Flags
- Read command-line argument
.play -edit examples/flags/flags.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Excercise: flags

#----------------------------------------------
* HTTP
#----------------------------------------------

* HTTP client

-TODO

#----------------------------------------------

* Excercise: http client

#----------------------------------------------

* HTTP server
.code examples/webserver/webserver.go /START OMIT/,/END OMIT/
- Fileserver and reverse proxy included

#----------------------------------------------

* Excercise: http server

#----------------------------------------------

#----------------------------------------------

* Debugging

- TODO

#----------------------------------------------

* Excercise: fix using debugger

#----------------------------------------------

* Templating
- web-server: generate html response using template
- code-generator: generate source-code from dsl
- Minimize logic in your template (move common concerns to template.FuncMap)

.play -edit examples/template/template.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* Excercise: templating

#----------------------------------------------

* Synchronisation
- Alternative to channels
- Use for small syncs or lazy initialisation
.play -edit examples/sync/sync.go /START OMIT/,/END OMIT/

#----------------------------------------------

* "Kind of" generics
- go get github.com/clipperhouse/gen
.code examples/generate/generate.go
  $ go generate ./...
  generates cyclist_slice.go with "SortBy"- and "Where"-methods on CyclistSlice
- Just commit and distribute with your package
.link https://github.com/MarcGrol/goopenkitchen/blob/master/generate/cyclist_slice.go cyclist_slice.go

#----------------------------------------------

* Static analysis

.code examples/staticanalysis/staticanalysis.go

- go vet, golint, gocyclo, varcheck, errcheck, ...
=> goreporter


#----------------------------------------------

* Excercise: detect problems with static analysis tools

#----------------------------------------------

* Complete tool-chain
  $ go list ./...                  # list sub-packages
  $ go list -f {{.Deps}}           # list external deps
  
  # no flame-wars, easy to diff, allow mechanical manipulation
  $ go fmt ./...                   # format recursively or
  $ goimports -w .                # even better: adds/removes imports
  
  # fetch external packages
  $ go get golang.org/x/tools/cmd/goimports # Be effective within seconds

  # testing: tooling supports coverage, benchmark, race-condition-detection
  $ go test ./...                  # test recursively 

  # compile
  $ go build or go run             # add hoc
  $ go install                     # to ${GOPATH}/bin

  $ godoc -http=:8000              # documentation of sources in ${GOROOT} and ${GOPATH}
  $ go vet                         # lint like static analysis

- All CLI -> Easy to automate

#----------------------------------------------

* Summary of language (fits on one sheet!!!!)
- Keywords:
    break case continue default defer else fallthrough for goto if return switch
    package import func const interface map range struct type chan go select var

- Types:
	error string rune bool byte int int8 int16 int32 int64 float32 float64
	uint uint8 uint16 uint32 uint64 uintptr complex64 complex128

- Constants:
	true false iota

- Zero value:
	nil

- Functions:
	append cap close complex copy delete len make new panic recover


#----------------------------------------------

* Simple build system
- Based on filesystem and conventions
- No Makefiles, autotools, build.xml, pom.xml etc
- The tool knows how to build
- Easy to integrate 3rd packages: only integrate source-code

#----------------------------------------------

* The goods
- Simple -> Easy to learn
- Source-code is easy to read and understand
- Easy deployment: self contained binary (no separate runtime)
- Supports cross compilation
- Well suited to host in the cloud: Very fast startup -> fast automatic scale-up while handling traffic spikes

#----------------------------------------------

* The not so good
# - Reproducable builds: versioning of 3rd party dependencies -> Vendoring
- No immutability by default
- Missing generics? -> Use code generation
- Go 2.0 will have generics

#----------------------------------------------

* So why go?
- Simple, readable language
- Rich standard libraries
- Complete tool-chain
- Good at concurrency
- Fast
- Easy to build and deploy
- Used by many startups
- Boring language -> is good

- Language to get things done

.link https://golang.org/

#----------------------------------------------

* Go do it
- Start experimenting
.image examples/images/gophereartrumpet.jpg
.caption Go is cool:  Tell it around
- Let's build something


#----------------------------------------------
* Extra's
#----------------------------------------------

* Switch
- On any type
- No fallthrough unless explicitly stated
- Multiple cases
.play -edit examples/switch/switch.go /START OMIT/,/END OMIT/

#----------------------------------------------
* Wrapping errors
TODO
#----------------------------------------------
* More on functions
#----------------------------------------------

* Package initialisation
  func init() {
    // your global initialisations here
  }

* Variadic functions
.play -edit examples/variadic/variadic.go

#----------------------------------------------

* Defer
- Cleanup of file-handles, mutexes, channels and connections
- Debugging: log "enter" and "leave" of function
- Unit-testing: "setup" and "teardown"

.play -edit examples/defer/defer.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Functions as parameters
- Single method interfaces, closures, anonymous functions
- Can reference variables from outside its function body.
.play -edit examples/closure/closure.go /START OMIT/,/END OMIT/

https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/

