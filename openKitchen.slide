Learning go
January 2018
Tags: go golang xebia

Marc Grol & Albert Brand

mgrol@xebia.com
https://github.com/MarcGrol/

abrand@xebia.com
https://github.com/AlbertBrand/

http://www.xebia.com

#----------------------------------------------

* About Marc

.image images/marc2.jpg
- Running, cycling

- Telecom, Finance, Mobile, Healthcare, Startups
- Allround, cost-benefit, agile, devops
- Running golang in production

#----------------------------------------------

* About Albert

.image images/albert.jpg 300 _
- Cooking, family man

- Finance, Mobile, E-commerce
- Agile, full-stack, nerdy
- Also running golang in production

#----------------------------------------------

* Day program

-  8:00 start
-  8:15 Go topics
-  9:00 exercise 1 & 2
- 10:00 break
- 10:15 Go topics
- 11:00 exercise 3
- 12:00 lunch break

Please interrupt for questions!

#----------------------------------------------

* Day program

- 13:00 Go topics
- 13:30 exercise 4
- 14:30 break
- 14:45 Nextail specific topics
- 15:30 exercise 5? / finish up
- 16:00 end

Please interrupt for questions!

#----------------------------------------------

* Your experience?

- Written code for how many years?
- Which other languages do you use?
- How did you learn? Tour, tutorial, read a book?
- Ever done JSON/XML marshalling?
- Ever built a http-client or http-server?
- Ever done multi-threaded code?
- Do you unit test? Integration test? Manual test?
- Do you have an open-source project?

#----------------------------------------------

* What is Go?

- Simple, readable language
- Rich standard libraries
- Complete tool-chain
- Good at concurrency
- Fast
- Easy to build and deploy
- Used by many startups
- Boring language (which is a good thing!)
- Language to get things done

#----------------------------------------------

* Why did Google create Go?

- Help Google solve problems: handle web requests
- Simple: limited -> easy to read
- Scale: infrastructure, teams, code bases
- Compile, startup and run fast
- Safe and reliable
- Optimum between C++ and Python

Also works for us @ Xebia

#----------------------------------------------

* Setup environment

- Install go:

.link https://golang.org/doc/install#download

    $ brew install go              # on mac
    $ sudo apt-get install golang  # on linux

- Verify installation
    $ which go     # typically located in /usr/local/bin/
    $ go env

- Optional post installation steps
    # Add installation dir to your PATH (in ~/.bash_profile)
    $ PATH=${PATH}:/usr/local/bin

#----------------------------------------------

* Workspace: GOPATH

- Directory ${GOPATH} contains all your personal go stuff
- Convention:
    ${GOPATH}
    ├── src/   # source code
    ├── pkg/   # libraries
    └── bin/   # executables
- The tooling knows how to build

- Post installation steps

    # Set ${GOPATH}/bin in your shell startup (~/.bash_profile)
    $ export GOPATH=~/src/go
    # add GOPATH to your PATH (~/.bash_profile)
    $ export PATH=${PATH}:${GOPATH}/bin

#----------------------------------------------

* Tooling

- Command line
- git
- Goland (or IntelliJ Ultimate w/plugin)
- VS Code w/plugin
- vi/sublime/your favorite text editor

#----------------------------------------------

* First program

    $ mkdir -p ${GOPATH}/src/github.com/<your-github-username>/hello
    $ cd ${GOPATH}/src/github.com/<your-github-username>/hello

- Source code: first.go
.play hello/first.go

    $ go fmt             # standard formatter

    $ go run first.go    # compiles and runs right away
    $ go build first.go  # creates executable "hello" in .
    $ go install         # creates executable "hello" in ${GOPATH}/bin

    $ hello
    Hi everybody!

#----------------------------------------------

* Summary of language (fits on one sheet)

- Keywords:
    break case continue default defer else fallthrough for goto if return switch
    package import func const interface map range struct type chan go select var

- Types:
	bool byte complex64 complex128 error float32 float64
	(u)int (u)int8 (u)int16 (u)int32 (u)int64 uintptr rune string

- Constants:
	true false iota

- Zero value:
	nil

- Functions:
	append cap close complex copy delete len make new panic recover

#----------------------------------------------

* Packages

- Each package in dedicated directory

- Standard packages shipped with Go in ${GOROOT}
    source in ${GOROOT}/src/...
    compiled in ${GOROOT}/pkg/...
    example: log, strings, io, errors, time, fmt, http, ....

- Your own or third-party packages in ${GOPATH}
    source-code in ${GOPATH}/src/...
    compiled in ${GOPATH}/pkg/...
    example: ${GOPATH}/src/github.com/gin-gonic/gin

- Package name first line of source file
     package main // package that results in executable
     package news // package that results in library "news.a"

- Packages are more coarse-grained than Java

#----------------------------------------------

* Imports

- Use fully qualified name
- Last part short and sweet: fmt, http, log, ..

.play -edit packaging/packaging.go

#----------------------------------------------

* Variables

.play -edit vars/vars.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Loops

- for
.play -edit for/for.go /START OMIT/,/END OMIT/

- while-like
.play -edit while/while.go /START OMIT/,/END OMIT/

#----------------------------------------------

* If, else

.play -edit if/if.go /START OMIT/,/END OMIT/

- No ternary operator (expr ? a : b)

#----------------------------------------------

* Switch

- On any type
- No fallthrough unless explicitly stated
- Multiple cases
.play -edit switch/switch.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Functions

- Core building block

- Scope: based on case
 func ConvertIt( arg int ) string {
     return convertInternal( arg )
 }
 func convertInternal( arg int ) string { // internal, unexported function
     return fmt.Sprintf( "My integer value as string: %d", arg)
 }

- Can return multiple values
 func swap(x, y string) (string, string) { 
    return y, x 
 }

- Package initialisation
  func init() {
    // your global initialisations here
  }

#----------------------------------------------

* Variadic functions

.play -edit variadic/variadic.go

#----------------------------------------------

* Functions as parameters

- Function-pointers, closures, anonymous functions
- Can reference variables from outside its function body.
.play -edit closure/closure.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Defer

- Useful for cleanup: file-handles, mutexes
- Useful for debugging: log "enter" and "leave" of function
- Useful for unit-testing: log "setup" and "teardown"

.play -edit defer/defer.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Struct and methods

- Compare Java class with methods
- Use pointer * when modifying struct
.play -edit struct/struct.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Pointers

- Pass "by value" is default
- For actions that mutate data: to pass "by reference"
- Useful for passing large objects around
- Beware of side effects

  var personP *Person = new(Person)
  personP.Name = "Boogerd"
  storePerson( personP )

  or
  
  person := Person{Name:"Boogerd"}
  storePerson( &person )

- Note: Slices, maps and channels are already refs
- Note: Pass by value has no side effects
.link https://github.com/MarcGrol/goopenkitchen/blob/master/pointers/pointers.go example


#----------------------------------------------

* Object construction

.play -edit construct/construct.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* Enum

.play -edit enum/enum.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Containers

- array
- slice
- map

#----------------------------------------------

* Array

- Fixed length, immutable
     numbers := [4]int{10, 20, 30, 40}
     
     fmt.Printf( "second value: %d", numbers[1] ) 

     // idiomatic: let compiler count
     s := [...]string{"Penn", "Teller"}

- Iterate over array
   for idx := 0 ; idx<4; idx++ {
      fmt.Printf("%d:%d\n", idx, numbers[idx])
   }

- Typical:   
   for idx, value := range numbers {
      fmt.Printf("%d:%d\n", idx, value)
   }

#----------------------------------------------

* Slice

- Dynamic array: can grow in size
    letters := []string{"a", "b", "c", "d"}
    subslice = letters[2:3] // c and d

    slice := []string{} // or
    slice := make( []string, 0, 5 ) or
    slice = append( slice, "first entry" )
    fmt.Printf( "slice-length: %d slice-capacity: %d slice-values:%+v",  
                    len(slice),
                    cap(slice),
                    slice)

- Iterate over slice (index optional -> use _)
 for idx, value := range values {
    fmt.Printf("values[%d] = %s\n", idx, value)
 }

- Sorting: use sort package

#----------------------------------------------

* Map

- Store key-value pairs

    m := make(map[string]int)
    m["route"] = 66
    // or preferred
    m := map[string]int {
        "route": 66,
    }
    delete(m, "route")
    i, ok := m["route"]

- Iterate over map
 for key, value := range numbers {
    fmt.Printf("%s - %d",key, value)
 }

- Random iteration order
- Not thread safe (combine with Mutex)

#----------------------------------------------

* Error handling

- Multiple return values
- if error is nil, the call worked
  resp, err := doSomethingThatCanFail(arg1, arg2)
  if err != nil {
      log.Printf("Error doing something that can fail: %s", err)
      return err
  }
  // continue with happy path

  // use _ (=blank) if you don't care
  resp, _ := doit(arg1, arg2)

- Function signature tells that things can go wrong
- All your own functions should use this pattern

#----------------------------------------------

* Interfaces
- UNIX philosophy: small, sharp tool combined to solve larger tasks
- go packages interact via small interfaces, no large hierarchies.
# decribe the "what", not the "how"

- example: I/O
   func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
   
   type Writer interface {
       Write(p []byte) (n int, err error)
   }
   "Writer" can be file, buffer, stdout, network, http-response, zip-file etc

- example: built-in interface "error"
   type error interface {
       Error() string
   }

# Refactor using interfaces when initially done

#----------------------------------------------

* Interface example

- Just implement the methods and you're done

.play -edit interfaces/interfaces.go

#----------------------------------------------

* Concurrency

Overemphasized
Most of your code is synchronous
Concurrent-style not forced upon you, used selectively

- built-in "channels" and "goroutines"
- Goroutines: think very, very lightweight threads
- Channels: think pipe or queue to communicate with goroutine
- "select"-loop in heart of program

#----------------------------------------------

* Concurrency example

- Do not communicate by sharing memory. Instead, share memory by communicating.

.play -edit channels/channels.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Select example

- Wait for events on multiple channels

.play -edit select/select.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Unit testing

- Part of toolchain
- In same package, dedicated file
- Filename convention: _test.go
.code testit/reverse_test.go /START OMIT/,/END OMIT/
    $ go test
    FAIL: TestDoit (0.00s)
    go_test.go:14: ERROR : Expecting[marc] Received[cram]

#----------------------------------------------

* More on testing

- Benchmarking
- Code coverage
- Race condition detection
- Http integration testing: see "httptest"-package

.link https://www.youtube.com/watch?v=ndmB0bj7eyw More details: google-search "testing techniques golang"

#----------------------------------------------

* Rich standard libraries

Just a few examples:
- flags
- file I/O
- sync
- logging
- os
- networking
- http, http2: client and server
- encoding (json, xml, mime)
- compression
- crypto
- templates
- sql
- integrating C-code
- ...

#----------------------------------------------

* Flags

- Read command-line argument
.play -edit flags/flags.go /START OMIT/,/END OMIT/

#----------------------------------------------

* HTTP server

.code webserver/webserver.go /START OMIT/,/END OMIT/
- Fileserver and reverse proxy included

#----------------------------------------------

* Synchronisation

- Alternative to channels
- Use for small syncs
.play -edit sync/sync.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Encoding / marshalling

.play -edit encoding/encoding.go  /^func main/,/^}/

#----------------------------------------------

* Templating

- web-server: generate html response using template
- Keep your template logic minimal -> move to structs or template.FuncMap
- Unit test your templates, they are not type-strong!

.play -edit template/template.go  /^func main/,/^}/

#----------------------------------------------

* "Kind of" generics

- go get github.com/clipperhouse/gen
.code generate/generate.go
  $ go generate ./...
  generates cyclist_slice.go with "SortBy"- and "Where"-methods on CyclistSlice
- Just commit and distribute with your package
.link https://github.com/MarcGrol/goopenkitchen/blob/master/generate/cyclist_slice.go cyclist_slice.go

#----------------------------------------------

* Complete tool-chain

  $ go list ./...                  # list sub-packages
  $ go list -f {{.Deps}}           # list external deps
  
  # no flame-wars, easy to diff, allow mechanical manipulation
  $ go fmt ./...                   # format recursively or
  $ goimports -w .                # even better: adds/removes imports
  
  # fetch external packages
  $ go get golang.org/x/tools/cmd/goimports # Be effective within seconds

  # testing: tooling supports coverage, benchmark, race-condition-detection
  $ go test ./...                  # test recursively 

  # compile
  $ go build or go run             # add hoc
  $ go install                     # to ${GOPATH}/bin

  $ godoc -http=:8000              # documentation of sources in ${GOROOT} and ${GOPATH}
  $ go vet                         # lint like static analysis

- All CLI -> Easy to automate

#----------------------------------------------

* Simple build system

- Based on filesystem and conventions
- No Makefiles, autotools, build.xml, pom.xml etc
- The tool knows how to build
- Easy to integrate 3rd packages: only integrate source-code

#----------------------------------------------

* Easy deployment

- Single, self contained binary
- No runtime
- Just scp to target host
- Supports cross compilation
- Well suited to host in the cloud (Google Appengine)

#----------------------------------------------

* The not so good

- Multiple vendoring solutions, no clear winner yet
- No immutability by default
- Missing generics, no clean solution

#----------------------------------------------

* Go do it

- Start experimenting
.image images/gophereartrumpet.jpg
.caption Go is cool:  Tell it around
- Let's build something

#----------------------------------------------
