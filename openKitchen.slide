The power of Go
7 April 2015
Tags: go golang xebia

Marc Grol
Software engineer, Xebia
mgrol@xebia.com
http://www.xebia.com/
https://github.com/MarcGrol/

#----------------------------------------------

* About me

.image ./marc.jpg
- Running, cycling

- Telco, Finance, Mobile
- C, C++, Java, Unix, DSL's, Go

#----------------------------------------------

* Approach
- Learn by example
- See code, run code
- Associate with something you already know
- Please interrupt for questions

#----------------------------------------------

* Your experience?
- Go installed on laptop?
- Written any code?
- Did tour, tutorial? Read a book?
- Used go tool-chain? go get, go install?
- Build http-client and http-server?
- json/xml marshalling?
- Used channels en goroutines?
- Unit testing?
- Own open-source project?

#----------------------------------------------

* Why go was created?
- Help Google solve problems
- Large scale infrastructure
- Large teams
- Massive code bases
- Run fast
- Compile fast
- Reliable
- Simple
- Optimum between C++ and Python
# Also works for us

#----------------------------------------------

* Setup environment

- Install
.link https://golang.org/doc/install#download

- Verify installation
    $ which go # typically located in /usr/local/go/bin/go
    $ go env

- Post installation steps
    # Set GOROOT in your shell startup (~/.bash_profile)
    $ export GOROOT=/usr/local/go

    # Add go to your PATH (in ~/.bash_profile)
    $ PATH=${PATH}:${GOROOT}/bin

#----------------------------------------------

* Workspace GOPATH

- Directory ${GOPATH} contains all your personal go stuff
- Convention:
    ${GOPATH}
    ├── src/   # source code
    ├── pkg/   # intermedia libraries objects
    └── bin/   # executables
- The tooling knows how to build

- Post installation steps

    # Set ${GOPATH}/bin in your shell startup (~/.bash_profile)
    $ export GOPATH=~/src/go
    # add GOPATH to your PATH (~/.bash_profile)
    $ export PATH=${PATH}:${GOPATH}/bin

#----------------------------------------------

* First program

    $ mkdir -p ${GOPATH}/src/github.com/<your-github-username>/hello
    $ cd ${GOPATH}/src/github.com/MarcGrol/hello

- Source code: first.go
.play ../hello/first.go

    $ go run first.go or
    $ go install # creates executable "hello" in ${GOPATH}/bin
    $ hello
    Hi everybody!

#----------------------------------------------

* Summary of language
- Keywords: 
    break case continue default defer else fallthrough for goto if return switch
    package import func const interface map range struct type chan go select var

- Types:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

- Constants:
	true false iota

- Zero value:
	nil

- Functions:
	append cap close complex copy delete len make new panic recover

#----------------------------------------------

* Packages

- Each package in dedicated directory

- Standard packages shipped with go
    source in ${GOROOT}/src
    compiled in ${GOROOT}/pkg/...
    example: log, strings, io, errors, time, fmt, http, ....

- Your own or third party packages
    source-code in ${GOPATH}/src/...
    compiled in ${GOPATH}/pkg/...
    example: ${GOPATH}/src/github.com/gin-gonic/gin

- Package name first line of source file
     package main // package that results in executable
     package news // package that results in library

#----------------------------------------------

* Imports

- Use fully qualified name

.code -edit package.go

#----------------------------------------------

* Variables
.play vars.go

#----------------------------------------------

* Functions
- Core building block
- Can return multiple values
 func swap(x, y string) (string, string) { 
    return y, x 
 }
- Scope: based on case
.code func.go

#----------------------------------------------

* More on functions
- Support variadic ...
- Module initialisation
  func init() {
    // your initialisations here
  }

#----------------------------------------------

* Functions as parameters
- callback-functions
- closures
- Can references variables from outside its function body.
.play closure.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Loops
- for
.play for.go /START OMIT/,/END OMIT/
- while-like
.play while.go /START OMIT/,/END OMIT/

#----------------------------------------------

* If, else
.play if.go

#----------------------------------------------

* Switch
- On any type
- No fallthrough unless explicitly stated
- Multiple cases
.play switch.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Defer
- Useful for cleanup: file-handles, mutexes
- Useful for logging enter, leave function

.play defer.go

#----------------------------------------------

* Struct and methods
- Compare Java class with methods
- Use pointer * when modifying struct
.play struct.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Pointers
- Pass by value is default
- Use pointers to pass by reference
- Useful for passing large objects around
- Slices, maps and channels are already refs

  var personP *Person = new(Person)
  personP.Name = "Boogerd"
  storePerson( personP )

  or
  
  person := Person(Name:"Boogerd")
  storePerson( &person )
- Pass by value has no side effects

#----------------------------------------------

* Object construction
.play construct.go  /START OMIT/,/END OMIT/

#----------------------------------------------

* Enum
.play enum.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Containers
- array
- slice
- map

#----------------------------------------------

* Array
- Fixed length immutable
     numbers := [4]int{10, 20, 30, 40}
     
     fmt.Printf( "second value: %d", numbers[1] ) 

     // idiomatic: let compiler count
     s := [...]string{"Penn", "Teller"}

- Iterate over array
   for idx := 0 ; idx<4; idx++ {
      fmt.Printf("%d:%d\n", idx, numbers[idx])
   }

- Typical:   
   for index, value := range numbers {
      fmt.Printf("%d:%d\n", index, value)
   }

#----------------------------------------------

* Slice
- Dynamic array: can grow in size

    letters := []string{"a", "b", "c", "d"}
    or
	slice := make([]string, 0, 5) // type, len, cap
    slice = append( slice, "first entry")
    fmt.Printf( "slice-length: %d slice-values:%+v", 
    			len(slice),
    			slice)
    subslice = slice[2:3]

- Iterate over slice
 for index, value := range numbers {
    fmt.Printf("%d:%d\n", index, value)
 }

- Sorting: use sort package

- Generics: use "gen" code-generator (github.com/clipperhouse/gen)

#----------------------------------------------

* Map
- Store key-value pairs

    m = make(map[string]int)
    m["route"] = 66
    delete(m, "route")
    i, ok := m["route"]

- Iterate over map
 for key, value := range numbers {
    fmt.Printf("%s - %d",key, value)
 }

- Random iteration order
- Not thread safe (combine with Mutex)

#----------------------------------------------

* Error handling
  resp, err := doit(arg1, arg2)
  if err != nil {
      return
  }
  // continue with success path

  // "blank":" if you don't care
  resp, _ := doit(arg1, arg2)

- if method return error, things can go wrong and you need to act on it
- if error is nil, the call worked
- You own API's should use this pattern

#----------------------------------------------

* Interfaces
- UNIX filosophy: small, sharp tool combined to solve larger tasks
- Instead of large runtimes, framework and hierarchies.
- go packages interact via interfaces, decribe the "what", not the "how"
- Just implement the methods and voila

- example: fmt.Fprintf to file, buffer, stdout, network, zip-file etc
- example: built-in interface "error"
    type error interface {
        Error() string
    }
- Refactor using interfaces when initially done

#----------------------------------------------

* Interface example

.play interfaces.go

#----------------------------------------------

# Whatever mix of packages you use: Consumers just have to understand a single error-handling strategy

* Concurrency

Most code is synchronous
Concurrent-style not forced upon you, used selectively


- built-in "channels" and "goroutines"
- Goroutines: think very, very lightweight threads
- Channels: think pipe or queue to communicate with coroutine
- "select"-loop in heart of program

#----------------------------------------------

* Concurrency example
- Share Memory By Communicating

.play channels.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Select example
- Waitfor events on multiple channels
- Do not block the loop!

.play select.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Unit testing
- Part of toolchain
- In same package, dedicated file
- Filename convention: _test.go
.code go_test.go /START OMIT/,/END OMIT/
    $ go test
    FAIL: TestDoit (0.00s)
    go_test.go:14: ERROR : Expecting[marc] Received[cram]

#----------------------------------------------

* More on testing
- Benchmarking
- Code coverage
- Race condition detection
- Http integration testing: see "httptest"-package https://github.com/MarcGrol/microgen/blob/master/tool/dsl/service-interface.go.tmpl template
.link https://www.youtube.com/watch?v=ndmB0bj7eyw see this youtube-link for more on testing

#----------------------------------------------

* Rich standard libraries
Just a few examples:
- flags
- http, http2
- file I/O
- sync
- networking
- encoding (json, xml, mime)
- compression
- crypto
- templates
- ...

#----------------------------------------------

* Flags
- Read command-line argument
.play flags.go /START OMIT/,/END OMIT/

#----------------------------------------------

* HTTP
.code webserver.go /START OMIT/,/END OMIT/
- Fileserver and reverse proxy included

#----------------------------------------------

* Synchronisation
- Alternative to channels
- Use for small syncs
.play sync.go /START OMIT/,/END OMIT/

#----------------------------------------------

* Encoding
.play encoding.go  /^func main/,/^}/

#----------------------------------------------

* Templating
- web-server: generate html
- code generation
.link https://github.com/MarcGrol/microgen/blob/master/application.go model
.link https://github.com/MarcGrol/microgen/blob/master/tool/dsl/service-interface.go.tmpl template

#----------------------------------------------

* "Kind of" generics
- go get github.com/clipperhouse/gen
.code generate.go
  $ go generate ./...
  generates cyclist_slice.go
- Just commit and distribute with your package

#----------------------------------------------

* Complete tool-chain
  $ go list ./...                  # list sub-packages
  $ go list -f {{.Deps}}           # list external deps
  
  # no wars, easy to diff, allow mechanical manipulation, static analysis
  $ go fmt ./...                   # format recursively
  
  # Be effective within seconds
  $ go get github.com/bitly/go-nsq # fetch external package

  # testing: tooliong supports coverage, benchmark, race-conditions
  $ go test ./...                  # test recursively 

  # compile
  $ go build or go run             # add hoc
  $ go install

  $ godoc -http=:8000              # documentation of ${GOROOT} and ${GOPATH}
  $ go vet                         # lint like

- CLI -> Easy to automate

#----------------------------------------------

* Simple build system
- Based on filesystem and conventions
- No Makefiles, autotools, build.xml, pom.xml etc
- The tool knows how to build
- Easy to integrate 3rd packages: only integrate source-code

#----------------------------------------------

* Easy deployment
- Single, self contained binary
- No runtime
- Just scp to target host

#----------------------------------------------

* The not so good
- Reproducable builds: versioning of 3rd party dependencies
- IDE support: vi, sublime, eclipse, intelliJ
- No immutability by default
- Missing generics?
# Use code generation?

#----------------------------------------------

* So why go?
- Simple, readable language
- Rich standard libraries
- Complete tool-chain
- Good at concurrency
- Fast
- Easy to deploy: self-contained static binaries
- Used by many startups

- Language to get things done

.link https://golang.org/

#----------------------------------------------

* Go do it
- Start experimenting
- Build something
.image gophereartrumpet.jpg
.caption Tell it around


#----------------------------------------------
